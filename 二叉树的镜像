/*
操作给定的二叉树，将其变换为源二叉树的镜像。
*/

//递归思路
public class Solution {
    public void Mirror(TreeNode root) {
        //如果根结点为空，就直接返回，退出方法
        if (root == null) return;
        //如果左右子树都为空的话，也不用做调整，直接返回
        if (root.left == null && root.right == null) return;
        //此时根结点是有左子树和右子树不都为空
        //对左右子结点进行交换
        TreeNode tempNode = root.left;
        root.left = root.right;
        root.right = tempNode;
        //再递归处理左子树和右子树
        Mirror(root.left);
        Mirror(root.right);
    }
}


//迭代思路
import java.util.Stack;
public class Solution {
    public void Mirror(TreeNode root) {
        //如果树为空或只存在一个根结点，就直接返回，退出方法
        if (root == null) return;
        if (root.left == null && root.right == null) return;
        //创建一个栈，先将根结点放入到栈中
        Stack<TreeNode> stackOfTree = new Stack<>();
        stackOfTree.push(root);
        //当栈内元素不为空时，就进入循环
        while (!stackOfTree.isEmpty()) {
            //先取出栈顶元素，也就是根结点
            TreeNode topOfStack = stackOfTree.pop();
            //如果栈顶元素结点的左子结点和右子节点不都为空时，就交换两个节点
            if (topOfStack.left != null || topOfStack.right != null) {
                TreeNode tempNode = topOfStack.left;
                topOfStack.left = topOfStack.right;
                topOfStack.right = tempNode;
            }
            //交换完成之后，再分别把栈顶元素结点的左右子节点分别插入到栈中
            if (topOfStack.left != null) {
                stackOfTree.push(topOfStack.left);
            }
            if (topOfStack.right != null) {
                stackOfTree.push(topOfStack.right);
            }
        }
    }
}
